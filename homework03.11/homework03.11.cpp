//Пространства имен
//Что это такое?
//Пространства имен(namespaces) - это механизм в C++, позволяющий группировать идентификаторы (имена переменных, функций, классов и т.д.) 
// в логические области.

//Зачем они нужны?
//Избежание конфликтов имен: в больших проектах с множеством файлов и библиотек, 
// использующих одни и те же имена, пространства имен позволяют избежать коллизий.
//Организация кода: группировка связанных элементов в пространства имен улучшает читаемость и структуру кода.
//Контроль над видимостью: можно ограничить доступ к идентификаторам внутри пространства имен, 
// делая их доступными только из определенных частей кода.

//Как объявляются?
namespace имя_пространства_имен {
    // Код, который нужно сгруппировать 
    // (переменные, функции, классы)
}

//Правила работы:
//Идентификаторы внутри пространства имен доступны с помощью оператора разрешения области видимости (::).
// Например, имя_пространства_имен::имя_идентификатора.
//Можно вкладывать пространства имен друг в друга. Например, пространство1::пространство2::имя_идентификатора.
//Используя директиву using namespace имя_пространства_имен;, вы можете сделать все идентификаторы 
// из этого пространства имен доступными в текущей области видимости.
// Однако, рекомендуется использовать using имя_пространства_имен::имя_идентификатора; для импорта только необходимых идентификаторов, 
// чтобы избежать возможных конфликтов.


 
//Перечисления
//Что это такое?
//Перечисления(enums) - это пользовательские типы данных, которые позволяют задавать набор именованных констант целых чисел.

//Зачем они нужны?
//Повышение читаемости: использование имен вместо чисел делает код более понятным.
//Безопасность: перечисления предотвращают использование некорректных значений, ограничивая набор допустимых значений.
//Удобство: можно легко менять значения констант в перечислении, не изменяя код, который их использует.

//Как объявляются?
enum имя_перечисления {
    значение1,
    значение2,
};

//Правила работы:
//Значения перечислений по умолчанию начинаются с 0, но их можно явно задавать.
//Значения перечисления можно использовать в выражениях и сравнениях.
//Перечисления создают свой собственный тип данных, что позволяет их использовать как типы аргументов функций или как типы возвращаемого значения.

//Пример:
#include <iostream>

    namespace Colors {// Пространство имён "Colors"
    enum Color { // Перечисление
        Red = 1,
        Green = 2,
        Blue = 3
    };
}

int main() {
    Colors::Color myColor = Colors::Color::Green;
    if (myColor == Colors::Color::Red) {
        std::cout << "Красный!" << std::endl;
    }
    else {
        std::cout << "Другой цвет!" << std::endl;
    }
    return 0;
}

//Пример с использованием в умном указателе:
#include <iostream>

template <typename T>
class UniquePtr {
private:
    T* ptr;
    enum class State { // Перечисление
        Uninitialized, // Указатель не инициализирован
        Initialized, // Указатель инициализирован
        Released // Указатель освобожден
    };
    State state;

public:
    // Запрещаем конструкторы копирования и присваивания
    UniquePtr(const UniquePtr& other) = delete;
    UniquePtr& operator=(const UniquePtr& other) = delete;

    // Конструктор по умолчанию
    UniquePtr() : ptr(nullptr), state(State::Uninitialized) {}

    // Конструктор инициализации указателем
    explicit UniquePtr(T* p) : ptr(p), state(State::Initialized) {}

    // Освобождение памяти
    void free() {
        if (state == State::Initialized) {
            delete ptr;
            ptr = nullptr;
            state = State::Released;
        }
    }

    // Открепление владения
    void release() {
        if (state == State::Initialized) {
            T* tmp = ptr;
            ptr = nullptr;
            state = State::Released;
            tmp; // Избегаем предупреждения об использовании неинициализированной переменной
        }
    }
};
